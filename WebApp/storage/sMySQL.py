import MySQLdbimport MySQLdb.cursorsfrom lib.config import CFG__all__ = ['MySQLReadHandle','MySQLSetHandle']class MySQLHandle:    HostName = None#    ConnectionPool = {}    dbHandle = None    dbCursor = None    def __init__(self, hostName, ReadOnly=False):         self.HostName = hostName        HostConf = CFG.getSection(hostName)        if HostConf is None:            errorMsg = "%s config not exits!" % self.HostName            raise NameError, errorMsg         self.getConn(HostConf)          def __del__(self):        if self.dbCursor is not None:            self.dbCursor.close()        if self.dbHandle is not None:            self.dbHandle.close()        #    def __new__(cls, hostName):#        if hostName not in cls.ConnectionPool.keys() :#            cls.ConnectionPool[hostName] = super().__new__(cls, hostName)##        return cls.ConnectionPool[hostName]    def getConn(self, HostConf):        self.dbHandle = MySQLdb.Connect(host=HostConf["host"],                            user=HostConf['user'],passwd=HostConf['password'],                            db=HostConf['db'])        self.dbCursor = self.dbHandle.cursor(MySQLdb.cursors.DictCursor)    def _execute(self, SQL, commit=False):        try:            status = self.dbCursor.execute(SQL)            if commit:                self.dbHandle.commit()            return status        except:            print "SQL %s on DB %s excuting wrong! " % (SQL, self.HostName)class MySQLReadHandle(MySQLHandle):    def read(self, SQL):        self._execute(SQL)        result = []        for row in self.dbCursor.fetchall():            result.append(row)        return result    def readOne(self, SQL):        self._execute(SQL)        return self.dbCursor.fetchone()    def get(self, tableName, whereCause, fieldList = [], limit=None, readOne=False):        if fieldList == []:            field = "*"        else:            field = ",".join(fieldList)        SQL = "SELECT %s FROM %s WHERE %s " % (field, tableName, whereCause)                if limit is not None:            if type(limit) == type(1):                SQL += "LIMIT %s " % ("limit 1")            elif len(limit) == 2:                SQL += "LIMIT %s, %s" % (limit[0], limit[1])        if readOne:            return self.readOne(SQL)        return self.read(SQL)class MySQLSetHandle(MySQLReadHandle):        SafeSet = True    def update(self, tableName, whereCause, upSet ):        SQL = "UPDATE `%s` SET " % tableName                updateSet = []        for field in upSet.keys():            updateSet.append("`%s` = %s" %(field, upSet[field]))        SQL += ",".join(updateSet)        SQL += " WHERE %s " %  whereCause        if self.SafeSet:            SQL += "  LIMIT 1"        return self._execute(SQL, True)    def insert(self, tableName, data):        SQL = "INSERT INTO `%s` (%s) VALUES (%s)" % (tableName, ",".join(data.keys()), ",".join(data.items()))        return self._execute(SQL, True)    def delete(self, tableName, whereCause):        SQL = "DELETE FROM %s WHERE %s" % (tableName, whereCause)        if self.SafeSet:            SQL += " LIMIT 1 "        return self._execute(SQL, True)