import MySQLdbfrom lib.config import CFG__all__ = ['MySQLReadHandle','MySQLSetHandle']class MySQLHandle:    HostName = None#    ConnectionPool = {}    dbHandle = None    dbCursor = None    def __init__(self, hostName, ReadOnly=False):         sefl.HostName = hostName        HostConf = CFG().getSection(hostName)        if HostConf is None:            errorMsg = "%s config not exits!" % self.HostName            raise NameError, errorMsg         self.getConn(HostConf)          def __del__(self):        if self.dbCursor is not None:            self.dbCursor.close()        if self.dbHandle is not None:            self.dbHandle.close()        #    def __new__(cls, hostName):#        if hostName not in cls.ConnectionPool.keys() :#            cls.ConnectionPool[hostName] = super().__new__(cls, hostName)##        return cls.ConnectionPool[hostName]    def getConn(self, HostConf):        self.dbHandle = MySQldb.Connect(host=HostConf["host"],                            user=HostConf['user'],passwd=HostConf['password'],                            db=HostConf['db'])        self.dbCursor = self.sqlHandle.cursor()    def _execute(self, SQL):        try:            return self.dbCursor.execute(SQL)        except:            print "SQL %s on DB %s excuting wrong! " % (SQL, self.HostName)class MySQLReadHandle(MySQLHandle):    def read(self, SQL):        self._execute(SQL)        result = []        for row in self.dbCursor.fetchall():            result.append(result)        return result    def readOne(self, SQL):        self._execute(SQL)        return self.dbCursor.fetchone()    def get(self, tableName, whereCause, fieldList = [], limit=None, readOne=False):        if fieldList == []:            field = "*"        else:            field = ",".join(fieldList)        SQL = "SELECT %s FROM %s WHERE %s " (field, tableName, whereCause)        if limit is not None:            if type(limit) == type(1):                SQL += "LIMIT %s " % limit 1            elif len(limit) == 2                SQL += "LIMIT %s, %s" % (limit[0], limit[1])        if readOne:            return self.readOne(SQL)        return self.read(SQL)class MySQLSetHandle(MySQLReadHandle):        SafeSet = True    def update(self, tableName, whereCause, upSet ):        SQL = "UPDATE `%s` SET " % tableName                updateSet = []        for field in upSet.keys():            updateSet.append("`%s` = %s" %(field, upSet[field))        SQL += ",".updateSet + " "        SQL += whereCause        if self.SafeSet:            SQL += "  LIMIT 1"        return self._execute(SQL)    def insert(self, tableName, data):        SQL = "INSERT INTO `" + tableName + "` ( " + ",".(data.keys()) + ") VALUES ( " + ",".(data.items()) + ")"        return self._execute(SQL)    def delete(self, tableName, whereCause):        SQL = "DELETE FROM %s WHERE %s" % (tableName, whereCause)        if self.SafeSet:            SQL += " LIMIT 1 "        return self._execute(SQL)